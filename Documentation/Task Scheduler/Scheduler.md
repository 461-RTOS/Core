# OURTOS Task Scheduler

OURTOS uses a Preemptive Task Scheduler, meaning the Task Scheduler reserves the right to halt any task's operation in order to allow another task to run.

The Task Scheduler relies on three factors in heirarchy inorder to deterministically schedule tasks so they can operate as intended:

1) Task Status
2) Task Priority
3) Last Runtime


## Task Status

The first factor that is considered by the scheduler when determining a task to run is the task's status.

A Task can be flagged as one of four states:

- Task `Ready`
- Task `Waiting`
- Task `Blocked`
- Task `Suspended`

### Ready State

Only when a task is marked as `Ready` is it made as a potential candidate to run by the scheduler.

### Waiting State

Tasks are marked as `Waiting` by Kernel functions.

When a task is marked as `Waiting` it is subject to a timeout, where the task is marked as `Ready` after the specified tick time has passed. `Waiting` tasks cannot be set to `Ready` by any other condition than the scheduler indicating the wait time has completed.

*See [OsDelay](./../Functions/OsDelay.md) for more information on the `Waiting` state*

### Blocked State

Tasks are marked as `Blocked` by Control Flow objects such as Semaphores or Mutexes.

A task marked `Blocked` has two conditions that can allow it to return to the `Ready` state:

1) The task can have the `Blocked` state returned to `Ready` by the object that marked it as `Blocked`.

2) Like `Waiting` tasks, `Blocked` Tasks have a timeout that can mark a task as `Ready` once the specified tick time has passed.

*For more information on the `Blocked` state, see [Semaphores](./../Functions/Semaphores.md) and [Mutexes](./../Functions/Mutexes.md)*

### Suspended State

While a task is marked `Suspended`, it is never scheduled until another task or interrupt clears the `Suspended` flag from the task. The `Suspended` flag can co-occur with any of the other task states. When the task is no longer suspended, the task will continue to be scheduled based on whatever other state is currently set.

*See [Suspend Functions](./../Functions/Suspend.md) for more information on the `Suspended` State*

## Task Priority

Once the scheduler determines a task is a valid candidate, its priority is evaluated. Tasks of Higher priority will always preempt lower priority tasks.

If a task with a lower priority is in the `Ready` state, it can only run when all tasks of higher priority are sleeping by being in one of non-ready task states.

In order from highest priority to lowest, the task priorities are:

- `PRIORITY_REALTIME`
- `PRIORITY_VERY_HIGH`
- `PRIORITY_HIGH`
- `PRIORITY_HIGH_NORMAL`
- `PRIORITY_NORMAL`
- `PRIORITY_LOW_NORMAL`
- `PRIORITY_LOW`
- `PRIORITY_IDLE`

Priorities can be selected according to the needs of the programmer. They do not have any unique properties from one another aside from higher priorities preempting lower priorities.

### The Idle Process

The Idle Process is designed as an empty loop that runs only when all other tasks are sleeping. The Idle Process 

Note that `PRIORITY_IDLE` is reserved for the idle process which is auto-generated by the kernel before starting (*See [OsStart](./../Functions/OsStart.md) for more details on starting the kernel*). The idle process should not share priority with any other tasks in order to ensure the idle state remains predicatble.

## Last Runtime


